#! /usr/bin/perl -w
#
# Copyright (C) 2008, 2009, 2011 Richard Kettlewell
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
#

use strict;
use POSIX;

=head1 NAME

polybuild - automatically build software on multiple hosts

=head1 SYNOPSIS

B<polybuild> [OPTIONS]... BRANCH|HOST...

=head1 DESCRIPTION

This program uses SSH to connect to multiple hosts to retrieve chosen
software packages, referred to as I<branches> from version control and
build and test them.

At present only B<bzr> and B<git> are supported.

While it runs, an B<index.html> file is written out showing current
status and with hyperlinks to build logs.

=head1 OPTIONS

=over

=item B<--config> PATH

Specifies the path to the configuration file.  The default is
I</etc/polybuild.conf>.

=item B<--exclude> BRANCH|HOST

Exclude a branch or host from the build.  B<--exclude> can be
specified more than once.

=item B<--email> ADDRESS

Email an HTML report to ADDRESS on completion.
Unless you use B<--base>, the logfile links in the email won't work.

=item B<--base> URL

Base URL for logfiles in emailed report.

=item B<--help>

Display usage message.

=item B<--version>

Display version number.

=back

Branches and hosts are selected as follows:

1) If branches are specified on the command line then only those
branches are built.  Similarly if hosts are specified on the command
line then only those hosts will be used.

2) If no branches are specified on the command line then all branches
are built.  Similarly if no hosts are specified on the command line
then all hosts are used.

3) B<--exclude> commands override all of the above.

=cut

sub ssh($$);
sub make_html($);
sub parse_line($$);
sub expand_environment($$);

my $css = "body {
  color: black;
  background-color: white
}

a:link, a:visited, a:active {
  color: black;
  text-decoration: none
}

h1 {
  background-color: #e0ffe0
}

table {
  border-collapse: collapse
}

colgroup.results {
  border-right: 1px solid black;
  border-top: 1px solid black;
  border-bottom: 1px solid black
}

colgroup#results0 {
  border-left: 1px solid black;
}

th.branch {
  text-align: right;
  border-left: 1px solid black;
  border-bottom: 1px solid black
}

th#branch0 {
  border-top: 1px solid black
}

th.host {
  padding-left: 4px;
  padding-right: 4px
}

th.os {
  background-color: #e0ffff;
  padding-left: 4px;
  padding-right: 4px
}

th.osver {
  border-bottom: 1px solid black;
  padding-left: 4px;
  padding-right: 4px
}

td.unbuilt {
  background-color: #c0c0c0;
  text-align: center;
  width: 2em
}

td.unready {
  background-color: #c0c0c0;
  text-align: center;
  width: 2em
}

td.suppressed {
  background-color: #c0c0c0;
  text-align: center;
  width: 2em
}

td.building {
  background-color: #ffff80;
  text-align: center;
  width: 2em
}

td.buildfail {
  background-color: #ff0000;
  text-align: center;
  width: 2em
}

td.buildok {
  background-color: #c0ffc0;
  text-align: center;
  width: 2em
}

td.checking {
  background-color: #ffff40;
  text-align: center;
  width: 2em
}

td.checkfail {
  background-color: #ff0000;
  text-align: center;
  width: 2em
}

td.checkok {
  background-color: #40ff40;
  text-align: center;
  width: 2em
}

td.down {
  background-color: #ff8000;
  text-align: center;
  width: 2em
}
";
my $version = "0.DEV";

# Parse command line
our $config = "/etc/polybuild.conf";
our @exclude = ();
our $email;                     # report email address
our $base;                      # report base URL
while(@ARGV > 0 and $ARGV[0] =~ /^-/) {
    local $_ = shift @ARGV;
    if($_ eq '--config') {
	$config = shift @ARGV;
    } elsif($_ eq '--email') {
        $email = shift @ARGV;
    } elsif($_ eq '--base') {
        $base = shift @ARGV;
    } elsif($_ eq '--exclude') {
	push(@exclude, shift @ARGV);
    } elsif($_ eq '--help') {
        print <<EOF;
Usage:
  polybuild [OPTIONS...] [BRANCH|HOST...]

Options:
  --config PATH                 Path to configuration file ./polybuild.conf)
  --exclude BRANCH|HOST         Suppress a branch or host
  --email ADDRESS               Email report to this address
  --base URL                    Base URL for links in logfile
  --help                        Display usage message

If any branches are specified on the command line then only those branches
are built; otherwise all branches are built.  The same applies to hosts.
--exclude overrides all of the above.
EOF
       exit 0;
    } elsif($_ eq '--version') {
       print "$version\n";
       exit 0;
    } else {
	die "ERROR: unknown option '$_'\n";
    }
}
our @include = @ARGV;

=head1 CONFIGURATION FILE

The configuration file contains global directives, host stanzas and
branch stanzas.  Stanzas start with a B<define-host> or
B<define-branch> directive and are followed by host-specific or
branch-specific directives.  These are conventionally indented to
illustrate the grouping but this is not enforced.

Blank lines and lines starting "#" are ignored.

Argument values may be quoted using double quotes.
Within double quotes, a backslash escapes any character.

Strings of the form B<${...}> in the configuration file are expanded
using macro definitions or environment variables.

=head2 Global Directives

The following global directives are suported.  They may appear
anywhere in the config file.

=over

=item B<define> NAME VALUE

Define a macro.  These participate in B<${...}> expansion in the
configuration file.

=item B<global-environ> NAME VALUE

Defines an environment variable to define on the build hosts.  Note
that these do NOT participate in B<${...}> expansion currently (but
this might be changed).

=item B<local-work> PATH

Defines the local work directory.  The default is B<_builds/_master>.
This will contain working trees and build logs.

=item B<suppress> HOST BRANCH

Suppress builds on a particular host/branch combination.

HOST and BRANCH are regexps, implicitly anchored to the ends of the
string.

=back

=head2 Host Stanzas

A host stanza starts B<define-host> NAME and is followed by per-host
directives.  The name need not be the hostname of the target host, it
could be an abbreviation.  Host-specific directives are:

=over

=item B<hostname> NAME

Defines the actual hostname to SSH to.  The default is the name given
in B<define-branch>.  This could optionally take the form USER@HOST.

=item B<group> NAME

Defines the group the host belongs to.  Two hosts in the same group
will not be used concurrently (but see B<group-limit> below).  The
idea is that you identify all the (virtual) hosts sharing the same
underlying hardware, and avoid overloading it by compiling on all its
VMs concurrently.

The default group name is the same as the name given in the
B<define-host> directive.

=item B<group-limit> COUNT

Defines the maximum number of concurrent jobs that will be run on this
group of hosts.  The default is 1.

=item B<os> PLATFORM

Defines the platform name.  This should take the form
PLATFORM-VERSION.  Platforms 'debian' and 'ubuntu' are special in that
a B<debian/rules> build will be performed on those platforms if
possible.

=item B<work> PATH

Defines the work directory for this host.  The default is
B<_builds/>NAME where NAME is as given in B<define-host>.

=item B<path> EXTRA-PATH

Defines a directory to add to the start of the path on this host.  For
instance on a Mac using Fink you might add B</sw/bin>.

=item B<environ> NAME VALUE

Adds a value to the environment on this host.

=item B<make> MAKE

Defines the name of B<make> on this host.  For instance you might
specify B<gmake> on a system with an inadequate native version.

=item B<scanner> COMMAND

Defines the static analyzer to use on this host.  For instance you
might use "scan-build -o scans" to use the Clang static analyzer.

=item B<clean> B<yes>|B<no>

If set to B<yes> (the default) then build trees are removed on
success.  If set to B<no> then they are not.

=back

=head2 Branch Stanzas

A branch stanza starts B<define-branch> NAME and is followed by
per-branch directives.  B<location> is mandatory.

=over

=item B<type> TYPE

Defines the branch type.  This can be B<git> or B<bzr>.  If it is not
set then B<polybuild> will attempt to guess from the location.

=item B<location> LOCATION

Defines the repository to clone.  This can be anything acceptable to
B<bzr> or B<git>.

=item B<checkout> BRANCH

Defines the sub-branch to switch to.  This is only useful with B<git>.

=back

=cut

# Parse configuration file
my $line = 0;
my $host;			# current host stanza
my $branch;			# current branch stanza
my $workdir = "_builds/_master"; # working directory
my $refresh_interval = 10;	# refresh interval
our %hosts = ();
our @hostorder = ();
our %branches = ();
our @branchorder = ();
our %defines = ();
our %globalenv = ();
our %group_limit = ();
our @suppress = ();
open(CONF,  "<$config") or die "ERROR: reading $config: $!\n";
while(defined($_ = <CONF>)) {
    ++$line;
    next if /^\#/ or !/\S/;	# skip blank and comment lines
    s/^\s+//;
    s/\s+$//;
    my @l = parse_line($_, "$config:$line");
    my $cmd = shift @l;
    @l = map(expand_environment($_, "$config:$line"), @l);
    if($cmd =~ /^define/) {
	undef $host;
	undef $branch;
    }
    if($cmd eq 'define-host') {
	$host = shift @l;
	push(@hostorder, $host) unless exists $hosts{$host};
	$hosts{$host} = {
	    'hostname' => $host,
	    'work' => "_builds/$host",
	    'state' => 'inactive',
	    'path' => [],
	    'environ' => {},
	    'make' => 'make',
	    'group' => $host,
            'clean' => 'yes',
	    };
    } elsif($cmd eq 'hostname') {
	die "$config:$line: 'hostname' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{hostname} = shift @l;
    } elsif($cmd eq 'group') {
	die "$config:$line: 'group' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{group} = shift @l;
    } elsif($cmd eq 'group-limit') {
	die "$config:$line: 'group-limit' outside 'define-host'\n"
	    unless defined $host;
	$group_limit{$hosts{$host}->{group}} = shift @l;
    } elsif($cmd eq 'os') {
	die "$config:$line: 'os' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{os} = shift @l;
    } elsif($cmd eq 'work') {
	die "$config:$line: 'work' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{work} = shift @l;
    } elsif($cmd eq 'path') {
	die "$config:$line: 'path' outside 'define-host'\n"
	    unless defined $host;
	push(@{$hosts{$host}->{path}}, shift @l);
    } elsif($cmd eq 'environ') {
	die "$config:$line: 'environ' outside 'define-host'\n"
	    unless defined $host;
	my $k = shift @l;
	my $v = shift @l;
	$hosts{$host}->{environ}->{$k} = $v;
    } elsif($cmd eq 'make') {
	die "$config:$line: 'make' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{make} = shift @l;
    } elsif($cmd eq 'scanner') {
	die "$config:$line: 'scanner' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{scanner} = shift @l;
    } elsif($cmd eq 'clean') {
	die "$config:$line: 'clean' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{clean} = shift @l;
    } elsif($cmd eq 'define-branch') {
	$branch = shift @l;
	push(@branchorder, $branch) unless exists $branches{$branch};
	$branches{$branch} = {
	    'state' => 'inactive',
	};
    } elsif($cmd eq 'location') {
	die "$config:$line: 'location' outside 'define-branch'\n"
	    unless defined $branch;
	$branches{$branch}->{location} = shift @l;
    } elsif($cmd eq 'type') {
	die "$config:$line: 'type' outside 'define-branch'\n"
	    unless defined $branch;
        my $type = shift @l;
        die "$config:$line: unknown branch type '$type'\n"
          unless $type eq 'bzr' or $type eq 'git';
	$branches{$branch}->{type} = $type;
    } elsif($cmd eq 'branch') {
	die "$config:$line: 'branch' outside 'define-branch'\n"
	    unless defined $branch;
	$branches{$branch}->{branch} = shift @l;
    } elsif($cmd eq 'define') {
	my $k = shift @l;
	my $v = shift @l;
	$defines{$k} = $v;
    } elsif($cmd eq 'global-environ') {
	my $k = shift @l;
	my $v = shift @l;
	$globalenv{$k} = $v;
    } elsif($cmd eq 'local-work') {
	$workdir = shift @l;
    } elsif($cmd eq 'suppress') {
        my $shost = shift @l;
        my $sbranch = shift @l;
        push(@suppress, [$shost, $sbranch]);
    } else {
	die "$config:$line: unknown verb '$cmd'\n";
    }
}
close CONF;

# Guess branch types where not stated
for my $branch (keys %branches) {
    next if exists $branches{$branch}->{type};
    die "ERROR: branch '${branch}' has no location"
      unless exists $branches{$branch}->{location};
    if($branches{$branch}->{location} =~ /git|bzr/) {
        $branches{$branch}->{type} = $&;
    } else {
        die "ERROR: cannot guess type for branch '{$branch}'\n";
    }
}

# Set default group limits
for my $host (keys %hosts) {
    my $group = $hosts{$host}->{group};
    if(!exists $group_limit{$hosts{$host}->{group}}) {
	$group_limit{$hosts{$host}->{group}} = 1;
    }
}

# Include/exclude rules.  First if any hosts (branches) are explicitly included
# then we activate those hosts (branches).
my $included_hosts = 0;
my $included_branches = 0;
for my $hb (@include) {
    if(exists $hosts{$hb}) {
	$hosts{$hb}->{state} = 'active';
	$included_hosts = 1;
    } elsif(exists $branches{$hb}) {
	$branches{$hb}->{state} = 'active';
	$included_branches = 1;
    } else {
	die "ERROR: '$hb' is neither a host nor a branch\n";
    }
}

# If no hosts (branches) were explicitly included then we activate all of them.
if(!$included_hosts) {
    for my $host (keys %hosts) {
	$hosts{$host}->{state} = 'active';
    }
}
if(!$included_branches) {
    for my $branch (keys %branches) {
	$branches{$branch}->{state} = 'active';
    }
}

# We apply any explicit exclusions last (trumping all of the above).
for my $hb (@exclude) {
    if(exists $hosts{$hb}) {
	$hosts{$hb}->{state} = 'inactive';
    } elsif(exists $branches{$hb}) {
	$branches{$hb}->{state} = 'inactive';
    } else {
	die "ERROR: '$hb' is neither a host nor a branch\n";
    }
}

# Create and enter the working directory
if(!-d $workdir) {
    if(system("mkdir", "-p", "-m0755", $workdir) != 0) {
	exit(1);
    }
}

# Attempt to create remote work directories
for my $host (keys %hosts) {
    next unless $hosts{$host}->{state} eq 'active';
    if(ssh($host, "mkdir -p -m0755 \Q$hosts{$host}->{work}\E")) {
        print STDERR "ERROR: marking host $host as down\n";
	$hosts{$host}->{state} = 'down';
    }
}

# Check out source code
my $failed = 0;
for my $branch (keys %branches) {
    next unless $branches{$branch}->{state} eq 'active';
    # Remove any old version
    cmd("rm", "-rf", $branch) if -e "$workdir/$branch";
    # Check out the latest version
    if($branches{$branch}->{type} eq 'bzr') {
        if(cmd("bzr", "clone", "-q", $branches{$branch}->{location}, $branch)) {
            print STDERR "ERROR: cannot get source code for $branch\n";
            $failed++;
        }
    } elsif($branches{$branch}->{type} eq 'git') {
        if(cmd("git", "clone", "-q", $branches{$branch}->{location}, $branch)) {
            print STDERR "ERROR: cannot get source code for $branch\n";
            $failed++;
        }
        if(exists $branches{$branch}->{branch}) {
            if(cmd("-chdir", "$workdir/$branch",
                   "git", "checkout", "-q", $branches{$branch}->{branch})) {
                print STDERR "ERROR: cannot checkout $branch branch $branches{$branch}->{branch}\n";
                ++$failed;
            }
        }
    }
}
exit 1 if $failed;

# Create the branch/host status array.  Possible statuses are:
#  unbuilt     - done nothing yet
#  building    - currently building
#  buildok     - built OK
#  buildfail   - failed to build
#  checking    - currently checking
#  checkok     - checked OK
#  checkfail   - failed to check
for my $branch (keys %branches) {
    next unless $branches{$branch}->{state} eq 'active';
    $branches{$branch}->{status} = {};
    for my $host (keys %hosts) {
	$branches{$branch}->{status}->{$host} = "unbuilt";
    }
}

# Apply suppressions
for my $hb (@suppress) {
    my ($shost, $sbranch) = @$hb;
    for my $branch (keys %branches) {
        for $host (keys %hosts) {
            if($host =~ /^($shost)$/
               and $branch =~ /^($sbranch)$/) {
                $branches{$branch}->{status}->{$host} = "suppressed";
            }
        }
    }
}

=head1 THE REPORT

The report is saved in a file during builds, and optionally emailed on
completion.  While the build is going a refresh is set so that the
report remains up to date (in most browsers).

Each row corresponds to a branch.  Each top-level column corresponds
to a host, with the hostname, OS platform and OS version given.  Below
this the column is divided in two, the left one for building and the
right one for checking.

The symbols in the report have the following meanings:

=over 8

=item B<b...>

Currently building.

=item B<B>

Build failed.

=item B<c...>

Currently testing.

=item B<C>

Testing failed.

=item B<:)>

Build or check completed OK.

=item B<D>

Host is down.

=item B<S>

Host/branch is suppressed.

=item B<?>

Not yet started.

=back

Each cell's color also indicates what's going on:

=over 8

=item green

Completed OK.

=item yellow

Underway.

=item red

Failed.

=item orange

Host is down.

=item grey

Not yet started, or suppressed.

=back

=cut

our %buildtextmap = (
    "unbuilt" => "?",
    "building" => "b...",
    "buildok" => ":)",
    "buildfail" => "B",
    "checking" => ":)",
    "checkok" => ":)",
    "checkfail" => ":)",
    "down" => "D",
    "suppressed" => "S",
);

our %checktextmap = (
    "unbuilt" => "?",
    "building" => "?",
    "buildok" => "?",
    "buildfail" => "?",
    "checking" => "c...",
    "checkok" => ":)",
    "checkfail" => "C",
    "down" => "D",
    "suppressed" => "S",
);

# Create the host status array.  Possible status are:
#  idle       - not doing anything
#  working    - building something
for my $host (keys %hosts) {
    $hosts{$host}->{status} = "idle";
}

# Main loop
for(;;) {
    # See if any subprocess have finished
    for my $host (keys %hosts) {
	next unless $hosts{$host}->{status} eq 'working';
	# See if this host's job has finished
	my $r = waitpid($hosts{$host}->{pid}, WNOHANG);
	if($r > 0) {
	    # It has; update the branch status
	    my $branch = $hosts{$host}->{branch};
	    if($branches{$branch}->{status}->{$host} eq 'building') {
		if($?) {
		    $branches{$branch}->{status}->{$host} = 'buildfail';
		} else {
		    $branches{$branch}->{status}->{$host} = 'buildok';
		}
	    } else {
		if($?) {
		    $branches{$branch}->{status}->{$host} = 'checkfail';
		} else {
		    $branches{$branch}->{status}->{$host}  = 'checkok';
                    if($hosts{$host}->{clean} eq 'yes') {
                        ssh($host, "rm -rf \Q$hosts{$host}->{work}/$branch\E");
                    }
		}
	    }
	    # ...and the host status
	    $hosts{$host}->{status} = 'idle';
	    print STDERR "$host $branch -> $branches{$branch}->{status}->{$host}\n";
	    make_html($refresh_interval);
	}
    }
    my %group_jobs = map(($_ => 0), keys %group_limit);
	                        # count of jobs per group
    my $working = 0;		# count of working hosts
    my $idle = 0;		# count of idle hosts
    for my $host (keys %hosts) {
	next unless $hosts{$host}->{state} eq 'active';
	if($hosts{$host}->{status} eq 'working') {
	    my $group = $hosts{$host}->{group};
	    ++$group_jobs{$group};
	    ++$working;
	} else {
	    ++$idle;
	}
    }
    if($idle == 0) {
	# No host is idle.  Wait a bit and try again.
	sleep(2);
	next;
    }
    # For each idle host look for some work to do
    for my $host (keys %hosts) {
	next unless $hosts{$host}->{state} eq 'active';
	next unless $hosts{$host}->{status} eq 'idle';
	my $group = $hosts{$host}->{group};
	next if $group_jobs{$group} >= $group_limit{$group};
	my $b;
	# Look for some work for this host to do
	for my $branch (keys %branches) {
	    next unless $branches{$branch}->{state} eq 'active';
	    my $s = $branches{$branch}->{status}->{$host};
	    if($s eq 'unbuilt' or $s eq 'buildok') {
		$b = $branch;
		last;
	    }
	}
	# Skip this host if there's no more work for it
	next unless defined $b;
	$hosts{$host}->{branch} = $b;
	my $w = $hosts{$host}->{work};
	my $env = "";
	for my $k (keys %globalenv) {
	    $env .= "$k=\Q$globalenv{$k}\E;export $k;"
	}
	my $e = $hosts{$host}->{environ};
	for my $k (keys %$e) {
	    $env .= "$k=\Q$e->{$k}\E;export $k;"
	}
	if(@{$hosts{$host}->{path}}) {
	    $env .= "PATH=" . join(":", @{$hosts{$host}->{path}}, "\$PATH") . ";export PATH;";
	}
	if($branches{$b}->{status}->{$host} eq 'unbuilt') {
	    # Copy the source code to the build host.  We could do this
	    # in the background too but for now we do it synchronously;
	    # it's probably not actually going to be a large proportion
	    # of the build time.
            my $scanner = "";
            if(exists $hosts{$host}->{scanner}) {
              $scanner = "$hosts{$host}->{scanner} ";
            }
	    ssh($host, "rm -rf \Q$w/$b\E");
	    cmd("rsync", "-r", "$b", "$hosts{$host}->{hostname}:$w/.");
	    # Start the build
	    $hosts{$host}->{pid} = background("$host.$b.BUILD.txt",
            sub {
		# Figure out how to build the software.  It would be
		# nice if we could put this logic into the config file
		# and provide per-branch overrides but for now this will
		# do.
		
		# On Debian-like systems we attempt a native build,
		# including producing .deb files.
		if(-d "$workdir/$b/debian"
		   and ($hosts{$host}->{os} =~ /^(debian|ubuntu)/i)) {
		    return ssh($host,
			       "$env cd \Q$w/$b\E && $scanner debian/rules build && fakeroot debian/rules binary");
		}
		# If there's an autogen.sh we run that and then configure
		# before doing the make
		if(-e "$workdir/$b/autogen.sh") {
		    return ssh($host,
			       "$env cd \Q$w/$b\E && bash ./autogen.sh && $scanner ./configure && $scanner $hosts{$host}->{make}");
		} elsif(-e "$workdir/$b/prepare") {
                    # Some of my old code uses 'prepare' instead
		    return ssh($host,
			       "$env cd \Q$w/$b\E && bash ./prepare && $scanner ./configure && $scanner $hosts{$host}->{make}");
		}
		# If there's a configure we run that before doing the make
		if(-e "$workdir/$b/configure") {
		    return ssh($host,
			       "$env cd \Q$w/$b\E && $scanner ./configure && $scanner $hosts{$host}->{make}");
		}
		# Hopefuly there is at least a makefile
		return ssh($host, "$env cd \Q$w/$b\E && $scanner $hosts{$host}->{make}");
	    });
	    $branches{$b}->{status}->{$host} = 'building';
	} else {
	    # Start the check
	    $hosts{$host}->{pid} = background("$host.$b.CHECK.txt",
	    sub {
		return ssh($host, "$env cd \Q$w/$b\E && $hosts{$host}->{make} check");
	    });
	    $branches{$b}->{status}->{$host} = 'checking';
	}
	# Count up number of working hosts
	++$working;
	$hosts{$host}->{status} = 'working';
	++$group_jobs{$group};
	print STDERR "$host $b -> $branches{$b}->{status}->{$host}\n";
	make_html($refresh_interval);
    }
    # If there's no hosts doing any work then quit
    last if $working == 0;
    # Wait a bit before going round again
    sleep(2);
}

make_html(0);

if(defined $email) {
    my %results = ();
    for my $host (keys %hosts) {
        if($hosts{$host}->{state} eq 'active') {
            for my $branch (keys %branches) {
                next unless $branches{$branch}->{state} eq 'active';
                my $s = $branches{$branch}->{status}->{$host};
                ++$results{$s};
            }
        } elsif($hosts{$host}->{state} eq 'down') {
            ++$results{down};
        }
    }
    my $subject = "";
    for my $status (sort keys %results) {
        $subject.= " $status:$results{$status}";
    }
    open(EMAIL, "|/usr/sbin/sendmail -oi -oee -odb -t")
      or die "ERROR: executing sendmail: $!\n";
    print EMAIL "Subject: polybuild:$subject\n";
    print EMAIL "To: $email\n";
    print EMAIL "Content-Type: text/html\n";
    print EMAIL "\n";
    print EMAIL genmail(defined $base
                        ? " <base href=\"$base\">\n"
                        : undef);
    close EMAIL or die "error closing pipe to sendmail: $?/$!\n";
}

sub make_html($) {
    my $refresh = shift;

    open(OUTPUT, ">index.html.new") or die "ERROR: index.html.new: $!\n";
    print OUTPUT genmail($refresh
                         ? " <meta http-equiv=refresh content=\"$refresh\">\n"
                         : undef);
    close OUTPUT;
    rename "index.html.new", "index.html" or die "ERROR: renaming index.html.new: $!\n";
}

sub genmail {
    my $head = shift;
    my @html = ();

    push(@html, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\">\n");
    push(@html, "<html><head>\n");
    push(@html, $head) if defined $head;
    push(@html, " <title>Build report</title>\n");
    push(@html, " <style type=\"text/css\">\n");
    push(@html, $css);
    push(@html, " </style>\n");
    push(@html, "</head>\n");
    push(@html, "<body>\n");
    push(@html, " <h1>Build Report</h1>\n");
    push(@html, " <table class=results>\n");

    push(@html, "  <colgroup class=branch>\n");
    push(@html, "   <col class=branch>\n");
    push(@html, "  </colgroup>\n");
    my $id = 0;
    for my $host (@hostorder) {
	next if $hosts{$host}->{state} eq 'inactive';
	push(@html, "  <colgroup id=results$id class=results>\n");
	push(@html, "   <col class=build>\n");
	push(@html, "   <col class=check>\n");
	push(@html, "  </colgroup>\n");
	++$id;
    }    
    push(@html, "  <thead>\n");
    
    push(@html, "   <tr class=host>\n");
    push(@html, "    <th class=corner>\n");

    $id = 0;
    for my $host (@hostorder) {
	next if $hosts{$host}->{state} eq 'inactive';
	push(@html, "    <th id=host$id colspan=2 class=host>$host\n");
	++$id;
    }

    push(@html, "   <tr class=platform>\n");
    push(@html, "    <th class=corner>\n");

    $id = 0;
    for my $host (@hostorder) {
	next if $hosts{$host}->{state} eq 'inactive';
	if($hosts{$host}->{os} =~ /-/) {
	    push(@html, "    <th id=os$id colspan=2 class=os>$`\n");
	} else {
	    push(@html, "    <th id=os$id colspan=2 class=os>$hosts{$host}->{os}\n");
	}
	++$id;
    }

    push(@html, "   <tr class=platform>\n");
    push(@html, "    <th class=corner>\n");

    $id = 0;
    for my $host (@hostorder) {
	next if $hosts{$host}->{state} eq 'inactive';
	if($hosts{$host}->{os} =~ /-/) {
	    push(@html, "    <th id=osver$id colspan=2 class=osver>$'\n");
	} else {
	    push(@html, "    <th id=osver$id colspan=2 class=osver>\n");
	}
	++$id;
    }
    push(@html, "  </thead>\n");
    push(@html, "  <tbody>\n");

    $id = 0;
    for my $branch (@branchorder) {
	next if $branches{$branch}->{state} eq 'inactive';
	push(@html, "   <tr class=results>\n");
	push(@html, "    <th id=branch$id class=branch>$branch\n");
	my $hid = 0;
	for my $host (@hostorder) {
	    next if $hosts{$host}->{state} eq 'inactive';
	    my $s = $branches{$branch}->{status}->{$host};

            if($hosts{$host}->{state} eq 'down') {
                $s = 'down';
            }
	    my $buildlog;
	    my $buildstate = 'unbuilt';
	    my $checklog;
	    my $checkstate = 'unready';

	    if($s =~ /^build/) {
		$buildlog = "$host.$branch.BUILD.txt";
		$buildstate = $s;
	    }
	    if($s =~ /^check/) {
		$buildlog = "$host.$branch.BUILD.txt";
		$buildstate = 'buildok';
		$checklog = "$host.$branch.CHECK.txt";
		$checkstate = $s;
	    }
            if($s eq 'down') {
                $buildstate = 'down';
                $checkstate = 'down';
            }
	    if(defined $buildlog) {
		push(@html, "    <td id=build$hid class=$buildstate>\n");
		push(@html, "     <a href=\"$workdir/$buildlog\" title=\"Build log\">\n");
		push(@html, "      $buildtextmap{$s}\n");
		push(@html, "     </a>\n");
	    } else {
		push(@html, "    <td id=build$hid class=$buildstate>$buildtextmap{$s}\n");
	    }
	    if(defined $checklog) {
		push(@html, "    <td id=check$hid class=$checkstate>\n");
		push(@html, "     <a href=\"$workdir/$checklog\" title=\"Check log\">\n");
		push(@html, "      $checktextmap{$s}\n");
		push(@html, "     </a>\n");
	    } else {
		push(@html, "    <td id=check$hid class=$checkstate>$checktextmap{$s}\n");
	    }
	    ++$hid;
	}
	++$id;
    }
    push(@html, "  </tbody>\n");
    push(@html, " </table>\n");
    return @html;
}

# cmd([OPTIONS,] PROG, ARG, ARG, ...) - execute command (NOT via the shell).
#
# Options:
#    -chdir DIR       change directory (default is $workdir)
sub cmd {
    my $dir = $workdir;
    if($_[0] eq '-chdir') {
        shift @_;
        $dir = shift @_;
    }
    print STDERR "EXEC: ", join(" ", @_), "\n";
    my $pid = fork();
    if(!defined $pid) {
	die "ERROR: fork: $!\n";
    }
    if($pid == 0) {
	chdir($dir) or die "ERROR: chdir $workdir: $!\n";
	exec(@_);
	die "ERROR: exec $_[0]: $!\n";
    }
    my $r = waitpid($pid, 0);
    if($r != $pid) {
	die "ERROR: waitpid: $!\n";
    }
    if($? != 0) {
	printf STDERR "ERROR: $_[0] returned %#x\n", $?;
    }
    return $?;
}

# ssh(HOST, CMD) - execute CMD on HOST via ssh (and therefore via the shell)
sub ssh($$) {
    my $host = shift;
    my $cmd = shift;

    return cmd("ssh", $hosts{$host}->{hostname}, $cmd);
}

# background(LOGFILE, SUBROUTINE) - start executing SUBROUTINE in a subprocess
# with output sent to LOGFILE; returns the PID.
sub background {
    my $log = shift;
    my $cmd = shift;
    my $pid = fork();
    if(!defined $pid) {
	die "ERROR: fork: $!\n";
    }
    if($pid == 0) {
	open(STDOUT, ">$workdir/$log") or die "ERROR: $workdir/$log: $!\n";
	open(STDERR, ">&STDOUT");
	open(STDIN, "</dev/null");
	POSIX::_exit(&$cmd(@_) ? 1 : 0);
    }
    return $pid;
}

# parse_line(LINE) - return LINE broken into a list
sub parse_line($$) {
  local $_ = shift;
  my $where = shift;
  my @l = ();
  while($_ ne '') {
    if(/^\s+/) {
      $_ = $';
      next;
    }
    if(/^"((\\.|[^\\\"])*)"/) {
      my $content = $1;
      $_ = $';
      $content =~ s/\\(.)/$1/g;
      push(@l, $content);
    } elsif(/^"/) {
      die "$where: malformed string literal\n";
    } elsif(/^[^"\s]+/) {
      push(@l, $&);
      $_ = $';                  #'
    }
  }
  return @l;
}

# Expand environment variables in a string
sub expand_environment($$) {
  local $_ = shift;
  my $where = shift;
  while(/\${([a-z0-9_]+)}/i) {
    my $k = $1;
    my $v = ($defines{$k} or $ENV{$k});
    if(!defined $v) {
      die "$where: unknown definition '$k'\n";
    }
    s/\${$k}/$v/g;
  }
  return $_;
}

=head1 SETUP

It is sensible to configure special-purpose user logins for automated
builds, to eliminate variation in the environment of "real" users.

On a Debian system:

  adduser --system --home /var/cache/build --shell /bin/bash build

Under OSX (you will need to pick an unused UID):

  dscl . -readall /Users UniqueID|awk '/[0-9]$/{print $2}'|sort
  # pick an unused UID below 500...
  sudo dscl . -create /Users/build
  sudo dscl . -create /Users/build UniqueID 299
  sudo dscl . -create /Users/build UserShell /bin/bash
  sudo dscl . -create /Users/build NFSHomeDirectory /Users/build
  sudo dscl . -create /Users/build PrimaryGroupID -1
  sudo dscl . -create /Users/build Password '*'
  sudo mkdir /Users/build
  sudo chown build /Users/build

On the master, create an SSH key:

  sudo su - build
  ssh-keygen -t rsa

On the build hosts copy the public key into I<.ssh/authorized_keys>.

Arrange for B<polybuild> to run (for instance) from cron as user
B<build>.

=head1 AUTHOR

Richard Kettlewell <rjk@greenend.org.uk>

=cut

# Local Variables:
# cperl-indent-level:4
# perl-indent-level:4
# End:
