#! /usr/bin/perl -w
#
# Copyright (C) 2008, 2009, 2011, 2013, 2014 Richard Kettlewell
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

use strict;
use POSIX;
use File::Find;

=head1 NAME

polybuild - automatically build software on multiple hosts

=head1 SYNOPSIS

B<polybuild> [OPTIONS]... BRANCH|HOST...

=head1 DESCRIPTION

This program uses SSH to connect to multiple hosts to retrieve chosen
software packages, referred to as I<branches> from version control and
build and test them.

At present only B<bzr> and B<git> are supported.

While it runs, an B<index.html> file is written out showing current
status and with hyperlinks to build logs.

=head1 OPTIONS

=over

=item B<--config> PATH

Specifies the path to the configuration file.  The default is
I</etc/polybuild.conf>.

=item B<--exclude> BRANCH|HOST

Exclude a branch or host from the build.  B<--exclude> can be
specified more than once.

=item B<--email> ADDRESS

Email an HTML report to ADDRESS on completion.
Unless you use B<--base>, the logfile links in the email won't work.

=item B<--base> URL

Base URL for logfiles in emailed report.

=item B<--help>

Display usage message.

=item B<--version>

Display version number.

=back

Branches and hosts are selected as follows:

1) If branches are specified on the command line then only those
branches are built.  Similarly if hosts are specified on the command
line then only those hosts will be used.

2) If no branches are specified on the command line then all branches
are built.  Similarly if no hosts are specified on the command line
then all hosts are used.

3) B<--exclude> commands override all of the above.

=cut

sub ssh($$);
sub make_html($);
sub parse_line($$);
sub expand_environment($$);

my $css = "body {
  color: black;
  background-color: white
}

a:link, a:visited, a:active {
  color: black;
  text-decoration: none
}

h1 {
  background-color: #e0ffe0
}

table {
  border-collapse: collapse
}

colgroup.results {
  border-right: 1px solid black;
  border-top: 1px solid black;
  border-bottom: 1px solid black
}

colgroup#results0 {
  border-left: 1px solid black;
}

th.branch {
  text-align: right;
  border-left: 1px solid black;
  border-bottom: 1px solid black
}

th#branch0 {
  border-top: 1px solid black
}

th.host {
  padding-left: 4px;
  padding-right: 4px
}

th.os, th.os0, th.os2 {
  background-color: #e0ffff;
  padding-left: 4px;
  padding-right: 4px
}

th.os1 {
  padding-left: 4px;
  padding-right: 4px
}

th.os2 {
  border-bottom: 1px solid black;
}

td.unbuilt {
  background-color: #c0c0c0;
  text-align: center;
  width: 2em
}

td.unready {
  background-color: #c0c0c0;
  text-align: center;
  width: 2em
}

td.suppressed {
  background-color: #c0c0c0;
  text-align: center;
  width: 2em
}

td.building {
  background-color: #ffff80;
  text-align: center;
  width: 2em
}

td.buildfail {
  background-color: #ff0000;
  text-align: center;
  width: 2em
}

td.buildok {
  background-color: #c0ffc0;
  text-align: center;
  width: 2em
}

td.checking {
  background-color: #ffff40;
  text-align: center;
  width: 2em
}

td.checkfail {
  background-color: #ff0000;
  text-align: center;
  width: 2em
}

td.checkok {
  background-color: #40ff40;
  text-align: center;
  width: 2em
}

td.down {
  background-color: #ff8000;
  text-align: center;
  width: 2em
}
";
my $version = "0.4";

# Parse command line
our $config = "/etc/polybuild.conf";
our @exclude = ();
our $email;                     # report email address
our $base;                      # report base URL
while(@ARGV > 0 and $ARGV[0] =~ /^-/) {
    local $_ = shift @ARGV;
    if($_ eq '--config') {
	$config = shift @ARGV;
    } elsif($_ eq '--email') {
        $email = shift @ARGV;
    } elsif($_ eq '--base') {
        $base = shift @ARGV;
    } elsif($_ eq '--exclude') {
	push(@exclude, shift @ARGV);
    } elsif($_ eq '--help') {
        print <<EOF;
Usage:
  polybuild [OPTIONS...] [BRANCH|HOST...]

Options:
  --config PATH                 Path to configuration file (polybuild.conf)
  --exclude BRANCH|HOST         Suppress a branch or host
  --email ADDRESS               Email report to this address
  --base URL                    Base URL for links in logfile
  --help                        Display usage message

If any branches are specified on the command line then only those branches
are built; otherwise all branches are built.  The same applies to hosts.
--exclude overrides all of the above.
EOF
       exit 0;
    } elsif($_ eq '--version') {
       print "$version\n";
       exit 0;
    } else {
	die "ERROR: unknown option '$_'\n";
    }
}
our @include = @ARGV;

=head1 CONFIGURATION FILE

The configuration file contains global directives, host stanzas and
branch stanzas.  Stanzas start with a B<define-host> or
B<define-branch> directive and are followed by host-specific or
branch-specific directives.  These are conventionally indented to
illustrate the grouping but this is not enforced.

Blank lines and lines starting "#" are ignored.

Argument values may be quoted using double quotes.
Within double quotes, a backslash escapes any character.

Strings of the form B<${...}> in the configuration file are expanded
using macro definitions or environment variables.

=head2 Global Directives

The following global directives are supported.  They may appear
anywhere in the config file.

=over

=item B<define> NAME VALUE

Define a macro.  These participate in B<${...}> expansion in the
configuration file.

=item B<global-environ> NAME VALUE

Defines an environment variable to define on the build hosts.  Note
that these do NOT participate in B<${...}> expansion currently (but
this might be changed).

=item B<local-work> PATH

Defines the local work directory.  The default is B<_builds/_master>.
This will contain working trees and build logs.

=item B<suppress> HOST BRANCH

Suppress builds on a particular host/branch combination.

HOST and BRANCH are regexps, implicitly anchored to the ends of the
string.

=back

=head2 Host Stanzas

A host stanza starts B<define-host> NAME and is followed by per-host
directives.  The name need not be the hostname of the target host, it
could be an abbreviation.  Host-specific directives are:

=over

=item B<hostname> NAME

Defines the actual hostname to SSH to.  The default is the name given
in B<define-branch>.  This could optionally take the form USER@HOST.

=item B<group> NAME

Defines the group the host belongs to.  Two hosts in the same group
will not be used concurrently (but see B<group-limit> below).  The
idea is that you identify all the (virtual) hosts sharing the same
underlying hardware, and avoid overloading it by compiling on all its
VMs concurrently.

The default group name is the same as the name given in the
B<define-host> directive.

=item B<group-limit> COUNT

Defines the maximum number of concurrent jobs that will be run on this
group of hosts.  The default is 1.

=item B<os> PLATFORM

Defines the platform name.  This should take the form
PLATFORM-VERSION.  Platforms 'debian' and 'ubuntu' are special in that
a B<debian/rules> build will be performed on those platforms if
possible.

=item B<work> PATH

Defines the work directory for this host.  The default is
B<_builds/>NAME where NAME is as given in B<define-host>.

=item B<path> EXTRA-PATH

Defines a directory to add to the start of the path on this host.  For
instance on a Mac using Fink you might add B</sw/bin>.

=item B<environ> NAME VALUE

Adds a value to the environment on this host.

=item B<make> MAKE

Defines the name of B<make> on this host.  For instance you might
specify B<gmake> on a system with an inadequate native version.

=item B<scanner> SCANNER

Defines the scanner to use on this host.
See below.

=item B<clean> B<yes>|B<no>

If set to B<yes> (the default) then build trees are removed on
success.  If set to B<no> then they are not.

=back

=head2 Branch Stanzas

A branch stanza starts B<define-branch> NAME and is followed by
per-branch directives.  B<location> is mandatory.

=over

=item B<type> TYPE

Defines the branch type.  This can be B<git> or B<bzr>.  If it is not
set then B<polybuild> will attempt to guess from the location.

=item B<location> LOCATION

Defines the repository to clone.  This can be anything acceptable to
B<bzr> or B<git>.

=item B<checkout> BRANCH

Defines the sub-branch to switch to.  This is only useful with B<git>.

=item B<depends> TARGET

Defines a branch which this branch depends on.  The outputs of the
dependency target will be included in the include and library search
paths of this branch's builds.

The target of the dependency must already have been defined.

Dependencies are B<not> honored on Debian/Ubuntu platforms (as
inferred from the platform name; see above).  This is because the
Debian build system computes package dependencies based on the
packages that shared libraries are found in.

=back

=head2 Scanner Stanzas

A scanner stanzer starts B<define-scanner> NAME and is followed by
per-scanner directives.  The NAME is used in per-host B<scanner>
directives.

=over

=item B<interposer> COMMAND

Defines the prefix to use this scanner.

=item B<directory> DIRECTORY

The directory where scan results will be stored.

This directory will be search for an B<index.html> file, which will be
linkedfrom the results page.

=back

The built-in scanner B<clang> is equivalent to:

  define-scanner clang
    interposer "scan-build -o _scans"
    directory _scans

Built-in scanners may be overridden by B<define-scanner> directives.

=cut

# Parse configuration file
my $line = 0;
my $host;			# current host stanza
my $branch;			# current branch stanza
my $scanner;                    # current scanner stanza
my $workdir = "_builds/_master"; # working directory
my $refresh_interval = 10;	# refresh interval
our %hosts = ();
our @hostorder = ();
our %branches = ();
our @branchorder = ();
our %defines = ();
our %globalenv = ();
our %group_limit = ();
our @suppress = ();
our %scanners = (
                 "clang" => {
                             "interposer" => ["scan-build -o _scans"],
                             "directory" => "_scans",
                            }
                );
open(CONF,  "<$config") or die "ERROR: reading $config: $!\n";
while(defined($_ = <CONF>)) {
    ++$line;
    next if /^\s*\#/ or !/\S/;	# skip blank and comment lines
    s/^\s+//;
    s/\s+$//;
    my @l = parse_line($_, "$config:$line");
    my $cmd = shift @l;
    @l = map(expand_environment($_, "$config:$line"), @l);
    if($cmd =~ /^define/) {
	undef $host;
	undef $branch;
        undef $scanner;
    }
    if($cmd eq 'define-host') {
	$host = shift @l;
	push(@hostorder, $host) unless exists $hosts{$host};
	$hosts{$host} = {
	    'hostname' => $host,
	    'work' => "_builds/$host",
	    'state' => 'inactive',
	    'path' => [],
	    'environ' => {},
	    'make' => 'make',
	    'group' => $host,
            'clean' => 'yes',
	    };
    } elsif($cmd eq 'hostname') {
	die "$config:$line: 'hostname' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{hostname} = shift @l;
    } elsif($cmd eq 'group') {
	die "$config:$line: 'group' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{group} = shift @l;
    } elsif($cmd eq 'group-limit') {
	die "$config:$line: 'group-limit' outside 'define-host'\n"
	    unless defined $host;
	$group_limit{$hosts{$host}->{group}} = shift @l;
    } elsif($cmd eq 'os') {
	die "$config:$line: 'os' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{os} = shift @l;
    } elsif($cmd eq 'work') {
	die "$config:$line: 'work' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{work} = shift @l;
    } elsif($cmd eq 'path') {
	die "$config:$line: 'path' outside 'define-host'\n"
	    unless defined $host;
	push(@{$hosts{$host}->{path}}, shift @l);
    } elsif($cmd eq 'environ') {
	die "$config:$line: 'environ' outside 'define-host'\n"
	    unless defined $host;
	my $k = shift @l;
	my $v = shift @l;
	$hosts{$host}->{environ}->{$k} = $v;
    } elsif($cmd eq 'make') {
	die "$config:$line: 'make' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{make} = shift @l;
    } elsif($cmd eq 'scanner') {
        die "$config:$line: 'scanner' outside 'define-host'\n"
            unless defined $host;
        my $scanner = shift @l;
	die "$config:$line: unrecognized scanner '$scanner'\n"
          unless exists $scanners{$scanner};
	$hosts{$host}->{scanner} = $scanner;
    } elsif($cmd eq 'clean') {
	die "$config:$line: 'clean' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{clean} = shift @l;
    } elsif($cmd eq 'define-branch') {
	$branch = shift @l;
	push(@branchorder, $branch) unless exists $branches{$branch};
	$branches{$branch} = {
	    'state' => 'inactive',
	};
    } elsif($cmd eq 'location') {
	die "$config:$line: 'location' outside 'define-branch'\n"
	    unless defined $branch;
	$branches{$branch}->{location} = shift @l;
    } elsif($cmd eq 'type') {
	die "$config:$line: 'type' outside 'define-branch'\n"
	    unless defined $branch;
        my $type = shift @l;
        die "$config:$line: unknown branch type '$type'\n"
          unless $type eq 'bzr' or $type eq 'git';
	$branches{$branch}->{type} = $type;
    } elsif($cmd eq 'checkout') {
	die "$config:$line: 'checkout' outside 'define-branch'\n"
	    unless defined $branch;
	$branches{$branch}->{checkout} = shift @l;
    } elsif($cmd eq 'depends') {
	die "$config:$line: 'depends' outside 'define-branch'\n"
	    unless defined $branch;
        my $target = shift @l;
        die "$config:$line: 'depends' on later branch\n"
          unless exists $branches{$target};
	$branches{$branch}->{depends}->{$target} = 1;
        $branches{$target}->{rdepends}->{$branch} = 1;
    } elsif($cmd eq 'define') {
	my $k = shift @l;
	my $v = shift @l;
	$defines{$k} = $v;
    } elsif($cmd eq 'global-environ') {
	my $k = shift @l;
	my $v = shift @l;
	$globalenv{$k} = $v;
    } elsif($cmd eq 'local-work') {
	$workdir = shift @l;
    } elsif($cmd eq 'suppress') {
        my $shost = shift @l;
        my $sbranch = shift @l;
        push(@suppress, [$shost, $sbranch]);
    } elsif($cmd eq 'define-scanner') {
        $scanner = shift @l;
        $scanners{$scanner} = {};
    } elsif($cmd eq 'directory'
            or $cmd eq 'interposer') {
        die "$config:$line: '$cmd' outside 'define-scanner'\n"
          unless defined $scanner;
        $scanners{$scanner}->{$cmd} = shift @l;
    } else {
	die "$config:$line: unknown verb '$cmd'\n";
    }
}
close CONF;

# Sanity-check scanners
for my $scanner (keys %scanners) {
    for my $key ("interposer", "directory") {
        if(!exists $scanners{$scanner}->{$key}) {
            die "$config: scanner '$scanner' missing '$key'\n";
        }
    }
}

# Guess branch types where not stated
for my $branch (keys %branches) {
    next if exists $branches{$branch}->{type};
    die "ERROR: branch '${branch}' has no location"
      unless exists $branches{$branch}->{location};
    if($branches{$branch}->{location} =~ /git|bzr/) {
        $branches{$branch}->{type} = $&;
    } else {
        die "ERROR: cannot guess type for branch '$branch'\n";
    }
}

# Set default group limits
for my $host (keys %hosts) {
    my $group = $hosts{$host}->{group};
    if(!exists $group_limit{$hosts{$host}->{group}}) {
	$group_limit{$hosts{$host}->{group}} = 1;
    }
}

# Include/exclude rules.  First if any hosts (branches) are explicitly included
# then we activate those hosts (branches).
my $included_hosts = 0;
my $included_branches = 0;
for my $hb (@include) {
    if(exists $hosts{$hb}) {
	$hosts{$hb}->{state} = 'active';
	$included_hosts = 1;
    } elsif(exists $branches{$hb}) {
	$branches{$hb}->{state} = 'active';
	$included_branches = 1;
    } else {
	die "ERROR: '$hb' is neither a host nor a branch\n";
    }
}

# If no hosts (branches) were explicitly included then we activate all of them.
if(!$included_hosts) {
    for my $host (keys %hosts) {
	$hosts{$host}->{state} = 'active';
    }
}
if(!$included_branches) {
    for my $branch (keys %branches) {
	$branches{$branch}->{state} = 'active';
    }
}

# We apply any explicit exclusions last (trumping all of the above).
for my $hb (@exclude) {
    if(exists $hosts{$hb}) {
	$hosts{$hb}->{state} = 'inactive';
    } elsif(exists $branches{$hb}) {
	$branches{$hb}->{state} = 'inactive';
    } else {
	die "ERROR: '$hb' is neither a host nor a branch\n";
    }
}

# Create and enter the working directory
if(!-d $workdir) {
    if(system("mkdir", "-p", "-m0755", $workdir) != 0) {
	exit(1);
    }
}

# Attempt to create remote work directories
for my $host (keys %hosts) {
    next unless $hosts{$host}->{state} eq 'active';
    if(ssh($host, "mkdir -p -m0755 \Q$hosts{$host}->{work}\E")) {
        print STDERR "ERROR: marking host $host as down\n";
	$hosts{$host}->{state} = 'down';
    }
    chomp($hosts{$host}->{work_abs} = `ssh $hosts{$host}->{hostname} cd \Q$hosts{$host}->{work}\E '&&' pwd`);
}

# Check out source code
my $failed = 0;
for my $branch (keys %branches) {
    next unless $branches{$branch}->{state} eq 'active';
    # Remove any old version
    cmd("rm", "-rf", $branch) if -e "$workdir/$branch";
    # Check out the latest version
    if($branches{$branch}->{type} eq 'bzr') {
        if(cmd("bzr", "clone", "-q", $branches{$branch}->{location}, $branch)) {
            print STDERR "ERROR: cannot get source code for $branch\n";
            $failed++;
        }
    } elsif($branches{$branch}->{type} eq 'git') {
        if(cmd("git", "clone", "-q", $branches{$branch}->{location}, $branch)) {
            print STDERR "ERROR: cannot get source code for $branch\n";
            $failed++;
        }
        if(exists $branches{$branch}->{checkout}) {
            if(cmd("-chdir", "$workdir/$branch",
                   "git", "checkout", "-q", $branches{$branch}->{checkout})) {
                print STDERR "ERROR: cannot checkout $branch branch $branches{$branch}->{checkout}\n";
                ++$failed;
            }
        }
    }
}
exit 1 if $failed;

# Create the branch/host status array.  Possible statuses are:
#  unbuilt     - done nothing yet
#  building    - currently building
#  buildok     - built OK
#  buildfail   - failed to build
#  checking    - currently checking
#  checkok     - checked OK
#  checkfail   - failed to check
for my $branch (keys %branches) {
    next unless $branches{$branch}->{state} eq 'active';
    $branches{$branch}->{status} = {};
    for my $host (keys %hosts) {
	$branches{$branch}->{status}->{$host} = "unbuilt";
    }
}

# Apply suppressions
for my $hb (@suppress) {
    my ($shost, $sbranch) = @$hb;
    for my $branch (keys %branches) {
        for $host (keys %hosts) {
            if($host =~ /^($shost)$/
               and $branch =~ /^($sbranch)$/) {
                $branches{$branch}->{status}->{$host} = "suppressed";
            }
        }
    }
}

=head1 THE REPORT

The report is saved in a file during builds, and optionally emailed on
completion.  While the build is going a refresh is set so that the
report remains up to date (in most browsers).

Each row corresponds to a branch.  Each top-level column corresponds
to a host, with the hostname, OS platform and OS version given.  Below
this the column is divided in two, the left one for building and the
right one for checking.

The symbols in the report have the following meanings:

=over 8

=item B<b...>

Currently building.

=item B<B>

Build failed.

=item B<c...>

Currently testing.

=item B<C>

Testing failed.

=item B<:)>

Build or check completed OK.

=item B<D>

Host is down.

=item B<S>

Host/branch is suppressed.

=item B<?>

Not yet started.

=back

Each cell's color also indicates what's going on:

=over 8

=item green

Completed OK.

=item yellow

Underway.

=item red

Failed.

=item orange

Host is down.

=item grey

Not yet started, or suppressed.

=back

=cut

our %buildtextmap = (
    "unbuilt" => "?",
    "building" => "b...",
    "buildok" => ":)",
    "buildfail" => "B",
    "checking" => ":)",
    "checkok" => ":)",
    "checkfail" => ":)",
    "down" => "D",
    "suppressed" => "-",
);

our %checktextmap = (
    "unbuilt" => "?",
    "building" => "?",
    "buildok" => "?",
    "buildfail" => "?",
    "checking" => "c...",
    "checkok" => ":)",
    "checkfail" => "C",
    "down" => "D",
    "suppressed" => "-",
);

our %scantextmap = (
    "unbuilt" => "?",
    "building" => "b...",
    "buildok" => "S",
    "buildfail" => "B",
    "checking" => "S",
    "checkok" => "S",
    "checkfail" => "S",
    "down" => "D",
    "suppressed" => "-",
);

# Create the host status array.  Possible status are:
#  idle       - not doing anything
#  working    - building something
for my $host (keys %hosts) {
    $hosts{$host}->{status} = "idle";
}

# Main loop
for(;;) {
    # See if any subprocess have finished
    for my $host (keys %hosts) {
	next unless $hosts{$host}->{status} eq 'working';
	# See if this host's job has finished
	my $r = waitpid($hosts{$host}->{pid}, WNOHANG);
	if($r > 0) {
	    # It has; update the branch status
	    my $branch = $hosts{$host}->{branch};
	    if($branches{$branch}->{status}->{$host} eq 'building') {
		if($?) {
		    $branches{$branch}->{status}->{$host} = 'buildfail';
		} else {
		    $branches{$branch}->{status}->{$host} = 'buildok';
		}
                # Capture static analysis output
                if(exists $hosts{$host}->{scanner}) {
                    my $d = $scanners{$hosts{$host}->{scanner}}->{directory};
                    my $w = $hosts{$host}->{work};
                    my $h = $hosts{$host}->{hostname};
                    # Retrieve the scanner results
                    cmd("rm", "-rf", "$host.$branch.SCAN");
                    cmd("scp", "-r", "$h:$w/$branch/$d", "$host.$branch.SCAN");
                    # Find the HTML
                    my $i;
                    find(sub {
                             $i = $File::Find::name if $_ eq 'index.html';
                         },
                         "$workdir/$host.$branch.SCAN");
                    $branches{$branch}->{scanout}->{$host} = $i
                      if defined $i;
                }
	    } else {
		if($?) {
		    $branches{$branch}->{status}->{$host} = 'checkfail';
		} else {
		    $branches{$branch}->{status}->{$host}  = 'checkok';
                    if($hosts{$host}->{clean} eq 'yes') {
                        ssh($host, "rm -rf \Q$hosts{$host}->{work}/$branch\E");
                    }
		}
	    }
	    # ...and the host status
	    $hosts{$host}->{status} = 'idle';
	    print STDERR "$host $branch -> $branches{$branch}->{status}->{$host}\n";
	    make_html($refresh_interval);
	}
    }
    my %group_jobs = map(($_ => 0), keys %group_limit);
	                        # count of jobs per group
    my $working = 0;		# count of working hosts
    my $idle = 0;		# count of idle hosts
    for my $host (keys %hosts) {
	next unless $hosts{$host}->{state} eq 'active';
	if($hosts{$host}->{status} eq 'working') {
	    my $group = $hosts{$host}->{group};
	    ++$group_jobs{$group};
	    ++$working;
	} else {
	    ++$idle;
	}
    }
    if($idle == 0) {
	# No host is idle.  Wait a bit and try again.
	sleep(2);
	next;
    }
    # For each idle host look for some work to do
    for my $host (keys %hosts) {
	next unless $hosts{$host}->{state} eq 'active';
	next unless $hosts{$host}->{status} eq 'idle';
	my $group = $hosts{$host}->{group};
	next if $group_jobs{$group} >= $group_limit{$group};
	my $b;
	# Look for some work for this host to do
	for my $branch (@branchorder) {
	    next unless $branches{$branch}->{state} eq 'active';
	    my $s = $branches{$branch}->{status}->{$host};
	    if($s eq 'unbuilt' or $s eq 'buildok') {
		$b = $branch;
		last;
	    }
	}
	# Skip this host if there's no more work for it
	next unless defined $b;
	$hosts{$host}->{branch} = $b;
	my $w = $hosts{$host}->{work};
	my $wa = $hosts{$host}->{work_abs};
	my $env = "";
        # Construct the environment
        my %env = ();
	for my $k (keys %globalenv) {
          $env{$k} = $globalenv{$k};
        }
	my $e = $hosts{$host}->{environ};
	for my $k (keys %$e) {
            $env{$k} = $e->{$k};
	}
        # Add ref to dependencies, on Debian-like hosts only
        if($hosts{$host}->{os} !~ /^(debian|ubuntu)/i) {
            for my $d (keys %{$branches{$b}->{depends}}) {
                $env{CPPFLAGS} .= " -I$wa/inst-$d/include";
                $env{LDFLAGS} .= " -L$wa/inst-$d/lib";
                #TODO how about bin?
            }
        }
        $env = "";
	for my $k (keys %env) {
	    $env .= "$k=\Q$env{$k}\E;export $k;"
	}
	if(@{$hosts{$host}->{path}}) {
	    $env .= "PATH=" . join(":", @{$hosts{$host}->{path}}, "\$PATH") . ";export PATH;";
	}
	if($branches{$b}->{status}->{$host} eq 'unbuilt') {
	    # Copy the source code to the build host.  We could do this
	    # in the background too but for now we do it synchronously;
	    # it's probably not actually going to be a large proportion
	    # of the build time.
	    ssh($host, "rm -rf \Q$w/$b\E");
	    cmd("rsync", "-r", "$b", "$hosts{$host}->{hostname}:$w/.");
            # Identify the static analyser to use
            my $scanprefix = "";
            if(exists $hosts{$host}->{scanner}) {
                $scanprefix = $scanners{$hosts{$host}->{scanner}}->{interposer};
            }
	    # Start the build
	    $hosts{$host}->{pid} = background("$host.$b.BUILD.txt",
            sub {
		# Figure out how to build the software.  It would be
		# nice if we could put this logic into the config file
		# and provide per-branch overrides but for now this will
		# do.
		my $has_configure_ac = -e "$workdir/$b/configure.ac";
		my $has_configure = -e "$workdir/$b/configure";
                my $has_debian = -d "$workdir/$b/debian"
                    && ($hosts{$host}->{os} =~ /^(debian|ubuntu)/i);
                my @build = ();
                push(@build, "$env cd \Q$w/$b\E");
                my $prefix;
                if($hosts{$host}->{os} !~ /^(debian|ubuntu)/i
                   and ${branches{$b}->{rdepends}}) {
                    $prefix = "$wa/inst-$b";
                    push(@build, "rm -rf \Q$prefix\E");
                    push(@build, "mkdir -p \Q$prefix\E");
                }
                # If there's an autogen.sh or similar we run that and
                # then configure before doing the make
                for my $autogen ("autogen.sh",
                                 "autogen",
                                 "prepare") {
                    if(-e "$workdir/$b/$autogen") {
                        push(@build, "./$autogen");
                        $has_configure = 1;
                        last;
                    }
                }
                if($has_configure_ac && !$has_configure) {
                    # Try autoreconf if the package doens't offer a
                    # bootstrap script
                    push(@build, "autoreconf -is");
                    $has_configure = 1;
                }
                if($has_debian) {
                    # On Debian-like systems we attempt a native build,
                    # including producing .deb files.
                    push(@build, "$scanprefix debian/rules build");
                    push(@build, "fakeroot debian/rules binary");
                } else {
                    my @make = ();
                    push(@make, $scanprefix);
                    push(@make, $hosts{$host}->{make});
                    if($has_configure) {
                        # Run configure if present
                        # ./configure may produce false positives, but
                        # http://clang-analyzer.llvm.org/scan-build.html
                        # recommends we run it under the scanner anyway.
                        my @configure = ();
                        push(@configure, $scanprefix);
                        push(@configure, "./configure");
                        push(@configure, "--prefix=\Q$prefix\E")
                          if defined $prefix;
                        push(@build, join(" ", @configure));
                    } else {
                        push(@make, "prefix=\Q$prefix\E")
                          if defined $prefix;
                    }
                    # There should be a makefile by now
                    push(@build, join(" ", @make));
                    if(${branches{$b}->{rdepends}}
                       and $hosts{$host}->{os} !~ /^(debian|ubuntu)/i) {
                        push(@build, join(" ", @make, "install"));
                    }
                }
                return ssh($host, join(" && ", @build));
	    });
	    $branches{$b}->{status}->{$host} = 'building';
	} else {
	    # Start the check
	    $hosts{$host}->{pid} = background("$host.$b.CHECK.txt",
	    sub {
		return ssh($host, "$env cd \Q$w/$b\E && $hosts{$host}->{make} check");
	    });
	    $branches{$b}->{status}->{$host} = 'checking';
	}
	# Count up number of working hosts
	++$working;
	$hosts{$host}->{status} = 'working';
	++$group_jobs{$group};
	print STDERR "$host $b -> $branches{$b}->{status}->{$host}\n";
	make_html($refresh_interval);
    }
    # If there's no hosts doing any work then quit
    last if $working == 0;
    # Wait a bit before going round again
    sleep(2);
}

make_html(0);

if(defined $email) {
    my %results = ();
    for my $host (keys %hosts) {
        if($hosts{$host}->{state} eq 'active') {
            for my $branch (keys %branches) {
                next unless $branches{$branch}->{state} eq 'active';
                my $s = $branches{$branch}->{status}->{$host};
                ++$results{$s};
            }
        } elsif($hosts{$host}->{state} eq 'down') {
            ++$results{down};
        }
    }
    my $subject = "";
    for my $status (sort keys %results) {
        $subject.= " $status:$results{$status}";
    }
    open(EMAIL, "|/usr/sbin/sendmail -oi -oee -odb -t")
      or die "ERROR: executing sendmail: $!\n";
    print EMAIL "Subject: polybuild:$subject\n";
    print EMAIL "To: $email\n";
    print EMAIL "Content-Type: text/html\n";
    print EMAIL "\n";
    print EMAIL genmail(defined $base
                        ? " <base href=\"$base\">\n"
                        : undef);
    close EMAIL or die "error closing pipe to sendmail: $?/$!\n";
}

sub make_html($) {
    my $refresh = shift;

    open(OUTPUT, ">index.html.new") or die "ERROR: index.html.new: $!\n";
    print OUTPUT genmail($refresh
                         ? " <meta http-equiv=refresh content=\"$refresh\">\n"
                         : undef);
    close OUTPUT;
    rename "index.html.new", "index.html" or die "ERROR: renaming index.html.new: $!\n";
}

sub genmail {
    my $head = shift;
    my @html = ();

    push(@html, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\">\n");
    push(@html, "<html><head>\n");
    push(@html, $head) if defined $head;
    push(@html, " <title>Build report</title>\n");
    push(@html, " <style type=\"text/css\">\n");
    push(@html, $css);
    push(@html, " </style>\n");
    push(@html, "</head>\n");
    push(@html, "<body>\n");
    push(@html, " <h1>Build Report</h1>\n");
    push(@html, " <table class=results>\n");

    push(@html, "  <colgroup class=branch>\n");
    push(@html, "   <col class=branch>\n");
    push(@html, "  </colgroup>\n");
    my $id = 0;
    for my $host (@hostorder) {
	next if $hosts{$host}->{state} eq 'inactive';
	push(@html, "  <colgroup id=results$id class=results>\n");
	push(@html, "   <col class=build>\n");
	push(@html, "   <col class=check>\n");
	push(@html, "   <col class=check>\n") if exists $hosts{$host}->{scanner};
	push(@html, "  </colgroup>\n");
	++$id;
    }    
    push(@html, "  <thead>\n");

    # Hostnames
    
    push(@html, "   <tr class=host>\n");
    push(@html, "    <th class=corner>\n");

    $id = 0;
    my $hrows = 0;
    for my $host (@hostorder) {
	next if $hosts{$host}->{state} eq 'inactive';
        my @bits = split(/-/, $hosts{$host}->{os});
        my $nbits = scalar @bits;
        $hrows = $nbits if $nbits > $hrows;
        my $colspan = 2 + exists $hosts{$host}->{scanner};
	push(@html, "    <th id=host$id colspan=${colspan} class=host>$host\n");
	++$id;
    }

    # OS versions (over as many rows as required)

    for(my $hrow = 0; $hrow < $hrows; ++$hrow) {
        push(@html, "   <tr class=platform>\n");
        push(@html, "    <th class=corner>\n");
        $id = 0;
        for my $host (@hostorder) {
            next if $hosts{$host}->{state} eq 'inactive';
            my @bits = split(/-/, $hosts{$host}->{os});
            my $bit = ($bits[$hrow] or "");
            my $colspan = 2 + exists $hosts{$host}->{scanner};
            push(@html, "    <th id=os$id colspan=${colspan} class=os${hrow}>$bit\n");
            ++$id;
        }
    }

    push(@html, "  </thead>\n");
    push(@html, "  <tbody>\n");

    $id = 0;
    for my $branch (@branchorder) {
	next if $branches{$branch}->{state} eq 'inactive';
	push(@html, "   <tr class=results>\n");
	push(@html, "    <th id=branch$id class=branch>$branch\n");
	my $hid = 0;
	for my $host (@hostorder) {
	    next if $hosts{$host}->{state} eq 'inactive';
	    my $s = $branches{$branch}->{status}->{$host};

            if($hosts{$host}->{state} eq 'down') {
                $s = 'down';
            }
	    my $buildlog;
	    my $buildstate = 'unbuilt';
	    my $checklog;
	    my $checkstate = 'unready';

	    if($s =~ /^build/) {
		$buildlog = "$host.$branch.BUILD.txt";
		$buildstate = $s;
	    }
	    if($s =~ /^check/) {
		$buildlog = "$host.$branch.BUILD.txt";
		$buildstate = 'buildok';
		$checklog = "$host.$branch.CHECK.txt";
		$checkstate = $s;
	    }
            if($s eq 'down') {
                $buildstate = 'down';
                $checkstate = 'down';
            }
	    if(defined $buildlog) {
		push(@html, "    <td id=build$hid class=$buildstate>\n");
		push(@html, "     <a href=\"$workdir/$buildlog\" title=\"Build log\">\n");
		push(@html, "      $buildtextmap{$s}\n");
		push(@html, "     </a>\n");
	    } else {
		push(@html, "    <td id=build$hid class=$buildstate>$buildtextmap{$s}\n");
	    }
	    if(defined $checklog) {
		push(@html, "    <td id=check$hid class=$checkstate>\n");
		push(@html, "     <a href=\"$workdir/$checklog\" title=\"Check log\">\n");
		push(@html, "      $checktextmap{$s}\n");
		push(@html, "     </a>\n");
	    } else {
		push(@html, "    <td id=check$hid class=$checkstate>$checktextmap{$s}\n");
	    }
            if(exists $hosts{$host}->{scanner}) {
                my $scanout = $branches{$branch}->{scanout}->{$host};
                if(defined $buildlog and defined $scanout) {
                    push(@html, "    <td id=scan$hid class=$buildstate>\n");
                    push(@html, "     <a href=\"$scanout\" title=\"Scanner output for $branch\">");
                    push(@html, "      $scantextmap{$s}\n");
                    push(@html, "     </a>\n");
                } else {
                    push(@html, "    <td id=scan$hid class=$buildstate>-\n");
                }
            }
	    ++$hid;
	}
	++$id;
    }
    push(@html, "  </tbody>\n");
    push(@html, " </table>\n");
    push(@html, "</body></html>\n");
    return @html;
}

# cmd([OPTIONS,] PROG, ARG, ARG, ...) - execute command (NOT via the shell).
#
# Options:
#    -chdir DIR       change directory (default is $workdir)
sub cmd {
    my $dir = $workdir;
    if($_[0] eq '-chdir') {
        shift @_;
        $dir = shift @_;
    }
    print STDERR "EXEC: ", join(" ", @_), "\n";
    my $pid = fork();
    if(!defined $pid) {
	die "ERROR: fork: $!\n";
    }
    if($pid == 0) {
	chdir($dir) or die "ERROR: chdir $workdir: $!\n";
	exec(@_);
	die "ERROR: exec $_[0]: $!\n";
    }
    my $r = waitpid($pid, 0);
    if($r != $pid) {
	die "ERROR: waitpid: $!\n";
    }
    if($? != 0) {
	printf STDERR "ERROR: $_[0] returned %#x\n", $?;
    }
    return $?;
}

# ssh(HOST, CMD) - execute CMD on HOST via ssh (and therefore via the shell)
sub ssh($$) {
    my $host = shift;
    my $cmd = shift;

    return cmd("ssh", $hosts{$host}->{hostname}, $cmd);
}

# background(LOGFILE, SUBROUTINE) - start executing SUBROUTINE in a subprocess
# with output sent to LOGFILE; returns the PID.
sub background {
    my $log = shift;
    my $cmd = shift;
    my $pid = fork();
    if(!defined $pid) {
	die "ERROR: fork: $!\n";
    }
    if($pid == 0) {
	open(STDOUT, ">$workdir/$log") or die "ERROR: $workdir/$log: $!\n";
	open(STDERR, ">&STDOUT");
	open(STDIN, "</dev/null");
	POSIX::_exit(&$cmd(@_) ? 1 : 0);
    }
    return $pid;
}

# parse_line(LINE) - return LINE broken into a list
sub parse_line($$) {
  local $_ = shift;
  my $where = shift;
  my @l = ();
  while($_ ne '') {
    if(/^\s+/) {
      $_ = $';
      next;
    }
    if(/^"((\\.|[^\\\"])*)"/) {
      my $content = $1;
      $_ = $';
      $content =~ s/\\(.)/$1/g;
      push(@l, $content);
    } elsif(/^"/) {
      die "$where: malformed string literal\n";
    } elsif(/^[^"\s]+/) {
      push(@l, $&);
      $_ = $';                  #'
    }
  }
  return @l;
}

# Expand environment variables in a string
sub expand_environment($$) {
  local $_ = shift;
  my $where = shift;
  while(/\$\{([a-z0-9_]+)\}/i) {
    my $k = $1;
    my $v = ($defines{$k} or $ENV{$k});
    if(!defined $v) {
      die "$where: unknown definition '$k'\n";
    }
    s/\${$k}/$v/g;
  }
  return $_;
}

=head1 BUILDS

Builds are constructed according to the following logic.

If I<autogen.sh> or I<prepare> exist, they are run.  It is assumed in
further steps that these will create I<configure>.

If I<configure.ac> exists but I<configure> does not exist then the
B<autoreconf -is> is run to generate it.

If a I<debian> directory exists and the host OS is Debian-like, the
build is performed by invoking B<debian/rules build> and then
B<fakeroot debian/rules binary>.  It is assumed that these will run
the configure script with appropriate arguments if necessary.

Otherwise, if I<configure> is present or has been created it is run
without arguments, followed by the host operating systems B<make>
command.

Finally B<make check> is run to perform tests.

=head2 Dependencies

In the non-Debian case if the branch is the target of a dependency
then B<make install> is performed to install the branch's build
products to a staging directory which the branches that depend on it
will use.

The staging directory is specified by the B<--prefix> argument to
I<configure> if that is used, and otherwise by B<prefix=> assignments
on each invocation of B<make>.

No extra B<prefix=> assignment is used when performing tests.

=head1 SETUP

It is sensible to configure special-purpose user logins for automated
builds, to eliminate variation in the environment of "real" users.

On a Debian system:

  adduser --system --home /var/lib/build --shell /bin/bash build

Under Fedora:

  useradd --system --create-home --shell /bin/bash build

Under OSX (you will need to pick an unused UID), to create the user:

  dscl . -readall /Users UniqueID|awk '/[0-9]$/{print $2}'|sort
  dscl . -readall /Groups PrimaryGroupID|awk '/[0-9]$/{print $2}'|sort
  # pick an unused UID and GID below 500...
  sudo dscl . -create /Groups/build
  sudo dscl . -create /Groups/build PrimaryGroupID 299
  sudo dscl . -create /Groups/build Password '*'
  sudo dscl . -create /Users/build
  sudo dscl . -create /Users/build UniqueID 299
  sudo dscl . -create /Users/build UserShell /bin/bash
  sudo dscl . -create /Users/build NFSHomeDirectory /Users/build
  sudo dscl . -create /Users/build PrimaryGroupID 299
  sudo dscl . -create /Users/build Password '*'
  sudo mkdir /Users/build
  sudo chown build /Users/build

...and to enable inbound SSH, if it is not already enabled:

  sudo dscl . append /Groups/com.apple.access_ssh User build
  sudo dscl . append /Groups/com.apple.access_ssh GroupMembers $(sudo dscl . read /Users/build GeneratedUID|awk '{print $2}')

Under FreeBSD:

  pw useradd build -c Builds -m -d /var/polybuild

On the master, create an SSH key:

  sudo su - build
  ssh-keygen -t rsa

On the build hosts copy the public key into I<.ssh/authorized_keys>.

Arrange for B<polybuild> to run (for instance) from cron as user
B<build>.

=head1 AUTHOR

Richard Kettlewell <rjk@greenend.org.uk>

=cut

# Local Variables:
# cperl-indent-level:4
# perl-indent-level:4
# End:
