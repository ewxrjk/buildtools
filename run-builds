#! /usr/bin/perl -w
use strict;
use POSIX;

=head1 NAME

run-builds - automatically build software on multiple hosts

=head1 SYNOPSIS

B<run-builds> [B<--config> PATH] [B<--exclude> BRANCH|HOST]... BRANCH|HOST...

=head1 DESCRIPTION

This program uses SSH to connect to multiple hosts to retrieve chosen
software packages, referred to as I<branches> from version control and
build and test them.

At present only B<bzr> is supported.

While it runs, an B<index.html> file is written out showing current
status and with hyperlinks to build logs.

=head1 OPTIONS

=over

=item B<--config> PATH

Specifies the path to the configuration file.  The default is
I<builds.conf>.

=item B<--exclude> BRANCH|HOST

Exclude a branch or host from the build.  B<--exclude> can be
specified more than once.

=back

Branches and hosts are selected as follows:

1) If branches are specified on the command line then only those
branches are built.  Similarly if hosts are specified on the command
line then only those hosts will be used.

2) If no branches are specified on the command line then all branches
are built.  Similarly if no hosts are specified on the command line
then all hosts are used.

3) B<--exclude> commands override all of the above.

=cut

sub ssh($$);
sub make_html($);

# We'll do our own process-reaping
#$SIG{CHLD} = 'IGNORE';

# Parse command line
our $config = "builds.conf";
our @exclude = ();
while(@ARGV > 0 and $ARGV[0] =~ /^-/) {
    local $_ = shift @ARGV;
    if($_ eq '--config') {
	$config = shift @ARGV;
    } elsif($_ eq '--exclude') {
	push(@exclude, shift @ARGV);
    } else {
	die "ERROR: unknown option '$_'\n";
    }
}
our @include = @ARGV;

=head1 CONFIGURATION FILE

The configuration file contains global directives, host stanzas and
branch stanzas.  Stanzas start with a B<define-host> or
B<define-branch> directive and are followed by host-specific or
branch-specific directives.  These are conventionally indented to
illustrate the grouping but this is not enforced.

Blank lines and lines starting "#" are ignored.

Strings of the form B<${...}> in the configuration file are expanded
using macro definitions or environment variables.

=head2 Global Directives

The following global directives are suported.  They may appear
anywhere in the config file.

=over

=item B<define> NAME VALUE

Define a macro.  These participate in B<${...}> expansion in the
configuration file.

=item B<global-environ> NAME VALUE

Defines an environment variable to define on the build hosts.  Note
that these do NOT participate in B<${...}> expansion currently (but
this might be changed).

=item B<local-work> PATH

Defines the local work directory.  The default is B<_builds/_master>.
This will contain working trees and build logs.

=back

=head2 Host Stanzas

A host stanza starts B<define-host> NAME and is followed by per-host
directives.  The name need not be the hostname of the target host, it
could be an abbreviation.  Host-specific directives are:

=over

=item B<hostname> NAME

Defines the actual hostname to SSH to.  The default is the name given
in B<define-branch>.  This could optionally take the form USER@HOST.

=item B<group> NAME

Defines the group the host belongs to.  Two hosts in the same group
will not be used concurrently.  The idea is that you identify all the
(virtual) hosts sharing the same underlying hardware, and avoid
overloading it by compiling on all its VMs concurrently.

The default group name is the same as the name given in the
B<define-host> directive.

=item B<os> PLATFORM

Defines the platform name.  This should take the form
PLATFORM-VERSION.  Platforms 'debian' and 'ubuntu' are special in that
a B<debian/rules> build will be performed on those platforms if
possible.

=item B<work> PATH

Defines the work directory for this host.  The default is
B<_builds/>NAME where NAME is as given in B<define-host>.

=item B<path> EXTRA-PATH

Defines a directory to add to the start of the path on this host.  For
instance on a Mac using Fink you might add B</sw/bin>.

=item B<environ> NAME VALUE

Adds a value to the environment on this host.

=item B<make> MAKE

Defines the name of B<make> on this host.  For instance you might
specify B<gmake> on a system with an inadequate native version.

=back

=head2 Branch Stanzas

A branch stanza starts B<define-branch> NAME and is followed by
per-branch directives.  B<location> is mandatory.

=over

=item B<location> LOCATION

Defines the branch to clone.  This can be anything acceptable to
B<bzr>.

=back

=cut

# Parse configuration file
my $line = 0;
my $host;			# current host stanza
my $branch;			# current branch stanza
my $workdir = "_builds/_master"; # working directory
my $refresh_interval = 10;	# refresh interval
our %hosts = ();
our @hostorder = ();
our %branches = ();
our @branchorder = ();
our %defines = ();
our %globalenv = ();
open(CONF,  "<$config") or die "ERROR: reading $config: $!\n";
while(defined($_ = <CONF>)) {
    ++$line;
    next if /^\#/ or !/\S/;	# skip blank and comment lines
    while(/\${([a-z0-9_]+)}/i) {
	my $k = $1;
	my $v = ($defines{$k} or $ENV{$k});
	if(!defined $v) {
	    die "$config:$line: unknown definition '$k'\n";
	}
	s/\${$k}/$v/g;
    }
    s/^\s+//;
    s/\s+$//;
    my @l = split(/\s+/, $_);
    my $cmd = shift @l;
    if($cmd =~ /^define/) {
	undef $host;
	undef $branch;
    }
    if($cmd eq 'define-host') {
	$host = shift @l;
	push(@hostorder, $host) unless exists $hosts{$host};
	$hosts{$host} = {
	    'hostname' => $host,
	    'work' => "_builds/$host",
	    'active' => 0,
	    'path' => [],
	    'environ' => {},
	    'make' => 'make',
	    'group' => $host,
	    };
    } elsif($cmd eq 'hostname') {
	die "$config:$line: 'hostname' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{hostname} = shift @l;
    } elsif($cmd eq 'group') {
	die "$config:$line: 'group' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{group} = shift @l;
    } elsif($cmd eq 'os') {
	die "$config:$line: 'os' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{os} = shift @l;
    } elsif($cmd eq 'work') {
	die "$config:$line: 'work' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{work} = shift @l;
    } elsif($cmd eq 'path') {
	die "$config:$line: 'path' outside 'define-host'\n"
	    unless defined $host;
	push(@{$hosts{$host}->{path}}, shift @l);
    } elsif($cmd eq 'environ') {
	die "$config:$line: 'environ' outside 'define-host'\n"
	    unless defined $host;
	my $k = shift @l;
	my $v = shift @l;
	$hosts{$host}->{environ}->{$k} = $v;
    } elsif($cmd eq 'make') {
	die "$config:$line: 'make' outside 'define-host'\n"
	    unless defined $host;
	$hosts{$host}->{make} = shift @l;
    } elsif($cmd eq 'define-branch') {
	$branch = shift @l;
	push(@branchorder, $branch) unless exists $branches{$branch};
	$branches{$branch} = {
	    'active' => 0,
	};
    } elsif($cmd eq 'location') {
	die "$config:$line: 'location' outside 'define-branch'\n"
	    unless defined $branch;
	$branches{$branch}->{location} = shift @l;
    } elsif($cmd eq 'define') {
	my $k = shift @l;
	my $v = shift @l;
	$defines{$k} = $v;
    } elsif($cmd eq 'global-environ') {
	my $k = shift @l;
	my $v = shift @l;
	$globalenv{$k} = $v;
    } elsif($cmd eq 'local-work') {
	$workdir = shift @l;
    } else {
	die "$config:$line: unknown verb '$cmd'\n";
    }
}
close CONF;

# Include/exclude rules.  First if any hosts (branches) are explicitly included
# then we activate those hosts (branches).
my $included_hosts = 0;
my $included_branches = 0;
for my $hb (@include) {
    if(exists $hosts{$hb}) {
	$hosts{$hb}->{active} = 1;
	$included_hosts = 1;
    } elsif(exists $branches{$hb}) {
	$branches{$hb}->{active} = 1;
	$included_branches = 1;
    } else {
	die "ERROR: '$hb' is neither a host nor a branch\n";
    }
}

# If no hosts (branches) were explicitly included then we activate all of them.
if(!$included_hosts) {
    for my $host (keys %hosts) {
	$hosts{$host}->{active} = 1;
    }
}
if(!$included_branches) {
    for my $branch (keys %branches) {
	$branches{$branch}->{active} = 1;
    }
}

# We apply any explicit exclusions last (trumping all of the above).
for my $hb (@exclude) {
    if(exists $hosts{$hb}) {
	$hosts{$hb}->{active} = 0;
    } elsif(exists $branches{$hb}) {
	$branches{$hb}->{active} = 0;
    } else {
	die "ERROR: '$hb' is neither a host nor a branch\n";
    }
}

# Create and enter the working directory
if(!-d $workdir) {
    if(system("mkdir", "-p", "-m0755", $workdir) != 0) {
	exit(1);
    }
}

# Attempt to create remote work directories
for my $host (keys %hosts) {
    next unless $hosts{$host}->{active};
    if(ssh($host, "mkdir -p -m0755 \Q$hosts{$host}->{work}\E")) {
	$hosts{$host}->{active} = 0;
    }
}

# Check out source code
my $failed = 0;
for my $branch (keys %branches) {
    next unless $branches{$branch}->{active};
    # Remove any old version
    cmd("rm", "-rf", $branch) if -e "$workdir/$branch";
    # Check out the latest version
    if(cmd("bzr", "clone", "-q", $branches{$branch}->{location}, $branch)) {
	print STDERR "ERROR: cannot get source code for $branch\n";
	$failed++;
    }
}
exit 1 if $failed;

# Create the branch/host status array.  Possible statuses are:
#  unbuilt     - done nothing yet
#  building    - currently building
#  buildok     - built OK
#  buildfail   - failed to build
#  checking    - currently checking
#  checkok     - checked OK
#  checkfail   - failed to check
for my $branch (keys %branches) {
    next unless $branches{$branch}->{active};
    $branches{$branch}->{status} = {};
    for my $host (keys %hosts) {
	$branches{$branch}->{status}->{$host} = "unbuilt";
    }
}

our %buildtextmap = (
    "unbuilt" => "?",
    "building" => "b...",
    "buildok" => ":)",
    "buildfail" => "B",
    "checking" => ":)",
    "checkok" => ":)",
    "checkfail" => ":)",
);

our %checktextmap = (
    "unbuilt" => "?",
    "building" => "?",
    "buildok" => "?",
    "buildfail" => "?",
    "checking" => "c...",
    "checkok" => ":)",
    "checkfail" => "C",
);

# Create the host status array.  Possible status are:
#  idle       - not doing anything
#  working    - building something
for my $host (keys %hosts) {
    $hosts{$host}->{status} = "idle";
}

# Main loop
for(;;) {
    # See if any subprocess have finished
    for my $host (keys %hosts) {
	next unless $hosts{$host}->{status} eq 'working';
	# See if this host's job has finished
	my $r = waitpid($hosts{$host}->{pid}, WNOHANG);
	if($r > 0) {
	    # It has; update the branch status
	    my $branch = $hosts{$host}->{branch};
	    if($branches{$branch}->{status}->{$host} eq 'building') {
		if($?) {
		    $branches{$branch}->{status}->{$host} = 'buildfail';
		} else {
		    $branches{$branch}->{status}->{$host} = 'buildok';
		}
	    } else {
		if($?) {
		    $branches{$branch}->{status}->{$host} = 'checkfail';
		} else {
		   $branches{$branch}->{status}->{$host}  = 'checkok';
		}
	    }
	    # ...and the host status
	    $hosts{$host}->{status} = 'idle';
	    print STDERR "$host $branch -> $branches{$branch}->{status}->{$host}\n";
	    make_html($refresh_interval);
	}
    }
    # Enumerate idle hosts
    my %working_groups = ();
    my $working = 0;
    my $idle = 0;
    for my $host (keys %hosts) {
	next unless $hosts{$host}->{active};
	if($hosts{$host}->{status} eq 'working') {
	    $working_groups{$hosts{$host}->{group}} = 1;
	    ++$working;
	} else {
	    ++$idle;
	}
    }
    if($idle == 0) {
	# No host is idle.  Wait a bit and try again.
	sleep(2);
	next;
    }
    # For each idle host look for some work to do
    for my $host (keys %hosts) {
	next unless $hosts{$host}->{active};
	next if exists $working_groups{$hosts{$host}->{group}};
	my $b;
	# Look for some work for this host to do
	for my $branch (keys %branches) {
	    next unless $branches{$branch}->{active};
	    my $s = $branches{$branch}->{status}->{$host};
	    if($s eq 'unbuilt' or $s eq 'buildok') {
		$b = $branch;
		last;
	    }
	}
	# Skip this host if there's no more work for it
	next unless defined $b;
	$hosts{$host}->{branch} = $b;
	my $w = $hosts{$host}->{work};
	my $env = "";
	for my $k (keys %globalenv) {
	    $env .= "$k=\Q$globalenv{$k}\E;export $k;"
	}
	my $e = $hosts{$host}->{environ};
	for my $k (keys %$e) {
	    $env .= "$k=\Q$e->{$k}\E;export $k;"
	}
	if(@{$hosts{$host}->{path}}) {
	    $env .= "PATH=" . join(":", @{$hosts{$host}->{path}}, "\$PATH") . ";export PATH;";
	}
	if($branches{$b}->{status}->{$host} eq 'unbuilt') {
	    # Copy the source code to the build host.  We could do this
	    # in the background too but for now we do it synchronously;
	    # it's probably not actually going to be a large proportion
	    # of the build time.
	    ssh($host, "rm -rf \Q$w/$b\E");
	    cmd("rsync", "-r", "$b", "$hosts{$host}->{hostname}:$w/.");
	    # Start the build
	    $hosts{$host}->{pid} = background("$host.$b.BUILD",
            sub {
		# Figure out how to build the software.  It would be
		# nice if we could put this logic into the config file
		# and provide per-branch overrides but for now this will
		# do.
		
		# On Debian-like systems we attempt a native build,
		# including producing .deb files.
		if(-d "$workdir/$b/debian"
		   and ($hosts{$host}->{os} =~ /^(debian|ubuntu)/i)) {
		    return ssh($host,
			       "$env cd \Q$w/$b\E && debian/rules build && fakeroot debian/rules binary");
		}
		# If there's a prepare we run that and then configure
		# before doing the make
		if(-e "$workdir/$b/prepare") {
		    return ssh($host,
			       "$env cd \Q$w/$b\E && bash ./prepare && ./configure && $hosts{$host}->{make}");
		}
		# If there's a configure we run that before doing the make
		if(-e "$workdir/$b/configure") {
		    return ssh($host,
			       "$env cd \Q$w/$b\E && ./configure && $hosts{$host}->{make}");
		}
		# Hopefuly there is at least a makefile
		return ssh($host, "$env cd \Q$w/$b\E && $hosts{$host}->{make}");
	    });
	    $branches{$b}->{status}->{$host} = 'building';
	} else {
	    # Start the check
	    $hosts{$host}->{pid} = background("$host.$b.CHECK",
	    sub {
		return ssh($host, "$env cd \Q$w/$b\E && $hosts{$host}->{make} check");
	    });
	    $branches{$b}->{status}->{$host} = 'checking';
	}
	# Count up number of working hosts
	++$working;
	$hosts{$host}->{status} = 'working';

	$working_groups{$hosts{$host}->{group}} = 1;
	print STDERR "$host $b -> $branches{$b}->{status}->{$host}\n";
	make_html($refresh_interval);
    }
    # If there's no hosts doing any work then quit
    last if $working == 0;
    # Wait a bit before going round again
    sleep(2);
}

make_html(0);

sub make_html($) {
    my $refresh = shift;
    open(OUTPUT, ">index.html.new") or die "ERROR: index.html.new: $!\n";

    print OUTPUT "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\">\n";
    print OUTPUT "<html><head>\n";
    if($refresh) {
	print OUTPUT " <meta http-equiv=refresh content=\"$refresh\">\n";
    }
    print OUTPUT " <title>Build report</title>\n";
    print OUTPUT " <link rel=StyleSheet type=\"text/css\" href=\"builds.css\">\n";
    print OUTPUT "</head>\n";
    print OUTPUT "<body>\n";
    print OUTPUT " <h1>Build Report</h1>\n";
    print OUTPUT " <table class=results>\n";

    print OUTPUT "  <colgroup class=branch>\n";
    print OUTPUT "   <col class=branch>\n";
    print OUTPUT "  </colgroup>\n";
    my $id = 0;
    for my $host (@hostorder) {
	next unless $hosts{$host}->{active};
	print OUTPUT "  <colgroup id=results$id class=results>\n";
	print OUTPUT "   <col class=build>\n";
	print OUTPUT "   <col class=check>\n";
	print OUTPUT "  </colgroup>\n";
	++$id;
    }    
    print OUTPUT "  <thead>\n";
    
    print OUTPUT "   <tr class=host>\n";
    print OUTPUT "    <th class=corner>\n";

    $id = 0;
    for my $host (@hostorder) {
	next unless $hosts{$host}->{active};
	print OUTPUT "    <th id=host$id colspan=2 class=host>$host\n";
	++$id;
    }

    print OUTPUT "   <tr class=platform>\n";
    print OUTPUT "    <th class=corner>\n";

    $id = 0;
    for my $host (@hostorder) {
	next unless $hosts{$host}->{active};
	if($hosts{$host}->{os} =~ /-/) {
	    print OUTPUT "    <th id=os$id colspan=2 class=os>$`\n";
	} else {
	    print OUTPUT "    <th id=os$id colspan=2 class=os>$hosts{$host}->{os}\n";
	}
	++$id;
    }

    print OUTPUT "   <tr class=platform>\n";
    print OUTPUT "    <th class=corner>\n";

    $id = 0;
    for my $host (@hostorder) {
	next unless $hosts{$host}->{active};
	if($hosts{$host}->{os} =~ /-/) {
	    print OUTPUT "    <th id=osver$id colspan=2 class=osver>$'\n";
	} else {
	    print OUTPUT "    <th id=osver$id colspan=2 class=osver>\n";
	}
	++$id;
    }
    print OUTPUT "  </thead>\n";
    print OUTPUT "  <tbody>\n";

    $id = 0;
    for my $branch (@branchorder) {
	next unless $branches{$branch}->{active};
	print OUTPUT "   <tr class=results>\n";
	print OUTPUT "    <th id=branch$id class=branch>$branch\n";
	my $hid = 0;
	for my $host (@hostorder) {
	    next unless $hosts{$host}->{active};
	    my $s = $branches{$branch}->{status}->{$host};

	    my $buildlog;
	    my $buildstate = 'unbuilt';
	    my $checklog;
	    my $checkstate = 'unready';

	    if($s =~ /^build/) {
		$buildlog = "$host.$branch.BUILD";
		$buildstate = $s;
	    }
	    if($s =~ /^check/) {
		$buildlog = "$host.$branch.BUILD";
		$buildstate = 'buildok';
		$checklog = "$host.$branch.CHECK";
		$checkstate = $s;
	    }
	    if(defined $buildlog) {
		print OUTPUT "    <td id=build$hid class=$buildstate>\n";
		print OUTPUT "     <a href=\"$workdir/$buildlog\" title=\"Build log\">\n";
		print OUTPUT "      $buildtextmap{$s}\n";
		print OUTPUT "     </a>\n";
	    } else {
		print OUTPUT "    <td id=build$hid class=$buildstate>$buildtextmap{$s}\n";
	    }
	    if(defined $checklog) {
		print OUTPUT "    <td id=check$hid class=$checkstate>\n";
		print OUTPUT "     <a href=\"$workdir/$checklog\" title=\"Check log\">\n";
		print OUTPUT "      $checktextmap{$s}\n";
		print OUTPUT "     </a>\n";
	    } else {
		print OUTPUT "    <td id=check$hid class=$checkstate>$checktextmap{$s}\n";
	    }
	    ++$hid;
	}
	++$id;
    }
    print OUTPUT "  </tbody>\n";
    print OUTPUT " </table>\n";
    close OUTPUT;
    rename "index.html.new", "index.html" or die "ERROR: renaming index.html.new: $!\n";
}

# cmd(PROG, ARG, ARG, ...) - execute command (NOT via the shell).  The
# command is always execute in the working directory.
sub cmd {
    print STDERR "EXEC: ", join(" ", @_), "\n";
    my $pid = fork();
    if(!defined $pid) {
	die "ERROR: fork: $!\n";
    }
    if($pid == 0) {
	chdir($workdir) or die "ERROR: chdir $workdir: $!\n";
	exec(@_);
	die "ERROR: exec $_[0]: $!\n";
    }
    my $r = waitpid($pid, 0);
    if($r != $pid) {
	die "ERROR: waitpid: $!\n";
    }
    if($? != 0) {
	printf STDERR "ERROR: $_[0] returned %#x\n", $?;
    }
    return $?;
}

# ssh(HOST, CMD) - exceute CMD on HOST via ssh (and therefore via the shell)
sub ssh($$) {
    my $host = shift;
    my $cmd = shift;

    return cmd("ssh", $hosts{$host}->{hostname}, $cmd);
}

# background(LOGFILE, SUBROUTINE) - start executing SUBROUTINE in a subprocess
# with output sent to LOGFILE; returns the PID.
sub background {
    my $log = shift;
    my $cmd = shift;
    my $pid = fork();
    if(!defined $pid) {
	die "ERROR: fork: $!\n";
    }
    if($pid == 0) {
	open(STDOUT, ">$workdir/$log") or die "ERROR: $workdir/$log: $!\n";
	open(STDERR, ">&STDOUT");
	open(STDIN, "</dev/null");
	POSIX::_exit(&$cmd(@_) ? 1 : 0);
    }
    return $pid;
}
